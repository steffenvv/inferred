// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`type inference works correctly for basic types 1`] = `
Object {
  "dtsOutput": "import { InferType, Validator } from \\".\\";
export declare const t1: Validator<string>;
export declare type T1 = InferType<typeof t1>;
",
  "errors": Array [],
  "jsOutput": "",
}
`;

exports[`type inference works correctly for functions with higher arity 1`] = `
Object {
  "dtsOutput": "import { InferType, Validated, FunctionValidator2, FunctionValidator3 } from \\".\\";
export declare const parseAndSumInts: FunctionValidator2<string, string, number>;
export declare type ParseAndSumInts = InferType<typeof parseAndSumInts>;
export declare const munge: FunctionValidator3<Validated<{
    name: string;
}>, number, boolean, string | boolean>;
export declare type Munge = InferType<typeof munge>;
",
  "errors": Array [],
  "jsOutput": "",
}
`;

exports[`type inference works correctly for nested object types 1`] = `
Object {
  "dtsOutput": "import { InferType, Validated, Validator } from \\".\\";
export declare const t1: Validator<Validated<{
    foo: readonly (string | null)[] | null | undefined;
    bar: number | null;
    baz: boolean | undefined;
}>>;
export declare const t2: Validator<Validated<{
    a: Validated<{
        foo: any;
        bar: any;
        baz: any;
    }>;
}>>;
export declare type T1 = InferType<typeof t1>;
export declare type T2 = InferType<typeof t2>;
",
  "errors": Array [],
  "jsOutput": "",
}
`;

exports[`type inference works correctly for nullary functions 1`] = `
Object {
  "dtsOutput": "import { InferType, FunctionValidator0 } from \\".\\";
export declare const getInt: FunctionValidator0<number>;
export declare type GetInt = InferType<typeof getInt>;
",
  "errors": Array [],
  "jsOutput": "",
}
`;

exports[`type inference works correctly for shallow object types 1`] = `
Object {
  "dtsOutput": "import { InferType, Validated, Validator } from \\".\\";
export declare const t1: Validator<Validated<{
    foo: string;
    bar: number;
    baz: boolean;
}>>;
export declare type T1 = InferType<typeof t1>;
",
  "errors": Array [],
  "jsOutput": "",
}
`;

exports[`type inference works correctly for shallow object types with arrays and optionals 1`] = `
Object {
  "dtsOutput": "import { InferType, Validated, Validator } from \\".\\";
export declare const t1: Validator<Validated<{
    foo: readonly (string | null)[] | null | undefined;
    bar: number | null;
    baz: boolean | undefined;
}>>;
export declare type T1 = InferType<typeof t1>;
",
  "errors": Array [],
  "jsOutput": "",
}
`;

exports[`type inference works correctly for unary functions 1`] = `
Object {
  "dtsOutput": "import { InferType, FunctionValidator1 } from \\".\\";
export declare const parseInt: FunctionValidator1<string, number>;
export declare type ParseInt = InferType<typeof parseInt>;
",
  "errors": Array [],
  "jsOutput": "",
}
`;

exports[`type inference works correctly for unions 1`] = `
Object {
  "dtsOutput": "import { InferType, Validated, Validator } from \\".\\";
export declare const anOutcome: Validator<Validated<{
    kind: \\"Success\\";
    data: readonly string[];
    timestamp: number;
}> | Validated<{
    kind: \\"Error\\";
    error: string;
    stackTrace: string | undefined;
}>>;
export declare type Outcome = InferType<typeof anOutcome>;
",
  "errors": Array [],
  "jsOutput": "",
}
`;
